<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Daris & Dimas - AI Enhanced</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(to bottom, #87CEEB, #98D8E8);
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: 'Press Start 2P', cursive;
      overflow: hidden;
    }
    
    #gameContainer {
      position: relative;
      width: 100%;
      max-width: 900px;
      height: 100%;
      max-height: 500px;
    }
    
    canvas {
      background: transparent;
      border: 3px solid #333;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
      width: 100%;
      height: 100%;
      display: block;
    }
    
    #mobileControls {
      display: none;
      position: absolute;
      bottom: 20px;
      left: 0;
      right: 0;
      text-align: center;
    }
    
    .control-btn {
      background: rgba(255, 255, 255, 0.7);
      border: 2px solid #333;
      border-radius: 50%;
      width: 80px;
      height: 80px;
      font-size: 24px;
      display: inline-flex;
      justify-content: center;
      align-items: center;
      margin: 0 10px;
      box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    .control-btn:active {
      transform: scale(0.95);
      background: rgba(255, 255, 255, 0.9);
    }
    
    #pauseBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.7);
      border: 2px solid #333;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 16px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      z-index: 10;
    }
    
    #soundBtn {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.7);
      border: 2px solid #333;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 16px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      z-index: 10;
    }
    
    @media (max-width: 768px) {
      #mobileControls {
        display: block;
      }
      
      body {
        padding: 10px;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <button id="pauseBtn">‚è∏</button>
    <button id="soundBtn">üîä</button>
    <div id="mobileControls">
      <div class="control-btn" id="jumpBtn">‚Üë</div>
      <div class="control-btn" id="duckBtn">‚Üì</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const pauseBtn = document.getElementById("pauseBtn");
    const soundBtn = document.getElementById("soundBtn");
    const jumpBtn = document.getElementById("jumpBtn");
    const duckBtn = document.getElementById("duckBtn");
    // ================== Mobile Controls ==================
duckBtn.addEventListener("touchstart", function(e) {
  e.preventDefault();
  e.stopPropagation(); // cegah ikut trigger canvas jump
  if (gameState === "play" && !dino.isJumping) {
    dino.isDucking = true;
    dino.height = 30;
  }
});

duckBtn.addEventListener("touchend", function(e) {
  e.preventDefault();
  e.stopPropagation(); // cegah ikut trigger canvas jump
  if (gameState === "play") {
    dino.isDucking = false;
    dino.height = 60;
  }
});


    
    // Set canvas size
    function resizeCanvas() {
      const container = document.getElementById("gameContainer");
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
    }
    
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Game state
    let gameState = "menu"; // menu, play, paused, gameover
    let soundEnabled = true;
    let highScore = localStorage.getItem('dinoHighScore') || 0;
    let gameSpeed = 6;
    let gravity = 0.6;
    let frameCount = 0;
    let score = 0;
    let distance = 0;
    
    // Dino properties
    const dino = {
      x: 50,
      y: 0,
      width: 60,
      height: 60,
      dy: 0,
      jumpPower: -12,
      isJumping: false,
      isDucking: false,
      legAnimation: 0,
      blinkAnimation: 0
    };
    
    // Game elements
    let obstacles = [];
    let clouds = [];
    let particles = [];
    let stars = [];
    let powerUps = [];
    
    // Background layers for parallax effect
    const bgLayers = [
      { x: 0, y: 0, width: 0, height: 0, speed: 0.2, image: new Image() },
      { x: 0, y: 0, width: 0, height: 0, speed: 0.5, image: new Image() },
      { x: 0, y: 0, width: 0, height: 0, speed: 1, image: new Image() }
    ];
    
    // Dino sprite
    const dinoSprite = {
      stand: new Image(),
      run1: new Image(),
      run2: new Image(),
      jump: new Image(),
      duck: new Image()
    };
    
    // Obstacle sprites
    const cactusSprite = new Image();
    const birdSprite = new Image();
    
    // Power-up sprite
    const starSprite = new Image();
    
    // Sound effects
    const sounds = {
      jump: new Audio(),
      score: new Audio(),
      gameOver: new Audio(),
      powerUp: new Audio()
    };
    
    // Load images
    function loadImages() {
      // For this demo, we'll use colored rectangles instead of images
      // In a real implementation, you would load actual image files
      
      // Create gradient backgrounds
      const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      skyGradient.addColorStop(0, '#87CEEB');
      skyGradient.addColorStop(1, '#98D8E8');
      
      // Set background colors for demonstration
      bgLayers[0].color = '#E0F6FF'; // Far background
      bgLayers[1].color = '#C8E6F5'; // Mid background
      bgLayers[2].color = '#B0D9F0'; // Near background
      
      // Set sprite colors for demonstration
      dinoSprite.stand.color = '#4CAF50';
      dinoSprite.run1.color = '#4CAF50';
      dinoSprite.run2.color = '#4CAF50';
      dinoSprite.jump.color = '#4CAF50';
      dinoSprite.duck.color = '#4CAF50';
      
      cactusSprite.color = '#8B4513';
      birdSprite.color = '#FF5722';
      starSprite.color = '#FFD700';
    }
    
    // Initialize game
    function init() {
      loadImages();
      resetGame();
      gameLoop();
    }
    
    // Reset game
    function resetGame() {
      dino.y = canvas.height - 150 - dino.height;
      dino.dy = 0;
      dino.isJumping = false;
      dino.isDucking = false;
      obstacles = [];
      clouds = [];
      particles = [];
      stars = [];
      powerUps = [];
      frameCount = 0;
      score = 0;
      distance = 0;
      gameSpeed = 6;
      
      // Initialize background layers
      bgLayers.forEach(layer => {
        layer.x = 0;
        layer.width = canvas.width;
        layer.height = canvas.height;
      });
      
      // Create initial clouds
      for (let i = 0; i < 5; i++) {
        clouds.push({
          x: Math.random() * canvas.width,
          y: Math.random() * (canvas.height / 2),
          width: 60 + Math.random() * 40,
          height: 30 + Math.random() * 20,
          speed: 0.2 + Math.random() * 0.3
        });
      }
    }
    
    // Draw menu
    function drawMenu() {
      // Draw background
      drawBackground();
      
      // Draw title
      ctx.fillStyle = '#333';
      ctx.font = '40px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.fillText('GHOFAR RUN', canvas.width / 2, canvas.height / 3);
      
      // Draw subtitle
      ctx.font = '16px "Press Start 2P"';
      ctx.fillText('Tugas BK, with AI enhanced', canvas.width / 2, canvas.height / 3 + 40);
      
      // Draw start instruction
      ctx.font = '20px "Press Start 2P"';
      ctx.fillText('Press ENTER to Start', canvas.width / 2, canvas.height / 2);
      
      // Draw high score
      ctx.font = '16px "Press Start 2P"';
      ctx.fillText('High Score: ' + highScore, canvas.width / 2, canvas.height / 2 + 40);
      
      // Draw controls info
      ctx.font = '12px "Press Start 2P"';
      ctx.fillText('SPACE or ‚Üë to Jump', canvas.width / 2, canvas.height / 2 + 80);
      ctx.fillText('‚Üì to Duck', canvas.width / 2, canvas.height / 2 + 100);
      
      // Draw animated dino
      const dinoY = canvas.height / 2 + 120 + Math.sin(frameCount * 0.05) * 10;
      drawDino(canvas.width / 2 - 30, dinoY, dino.width, dino.height, 'run');
      
      // Draw ground
      drawGround();
    }
    
    // Draw game over screen
    function drawGameOver() {
      // Draw background
      drawBackground();
      drawGround();
      
      // Draw game over text
      ctx.fillStyle = '#FF0000';
      ctx.font = '40px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.fillText('WKWKWKWKWK', canvas.width / 2, canvas.height / 3);
      
      // Draw score
      ctx.fillStyle = '#333';
      ctx.font = '20px "Press Start 2P"';
      ctx.fillText('Score: ' + score, canvas.width / 2, canvas.height / 2 - 40);
      
      // Draw high score
      if (score > highScore) {
        ctx.fillStyle = '#FFD700';
        ctx.fillText('NEW HIGH SCORE!', canvas.width / 2, canvas.height / 2);
        highScore = score;
        localStorage.setItem('dinoHighScore', highScore);
      } else {
        ctx.fillStyle = '#333';
        ctx.fillText('High Score: ' + highScore, canvas.width / 2, canvas.height / 2);
      }
      
      // Draw restart instruction
      ctx.font = '20px "Press Start 2P"';
      ctx.fillText('Press ENTER to Restart', canvas.width / 2, canvas.height / 2 + 40);
      
      // Draw dead dino
      drawDino(dino.x, dino.y, dino.width, dino.height, 'dead');
    }
    
    // Draw pause screen
    function drawPauseScreen() {
      // Draw semi-transparent overlay
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw pause text
      ctx.fillStyle = '#FFF';
      ctx.font = '40px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
      
      // Draw resume instruction
      ctx.font = '20px "Press Start 2P"';
      ctx.fillText('Press P to Resume', canvas.width / 2, canvas.height / 2 + 40);
    }
    
    // Draw background with parallax effect
    function drawBackground() {
      // Draw sky gradient
      const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      skyGradient.addColorStop(0, '#87CEEB');
      skyGradient.addColorStop(1, '#98D8E8');
      ctx.fillStyle = skyGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw clouds
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      clouds.forEach(cloud => {
        // Draw cloud with multiple circles
        ctx.beginPath();
        ctx.arc(cloud.x, cloud.y, cloud.height / 2, 0, Math.PI * 2);
        ctx.arc(cloud.x + cloud.width * 0.25, cloud.y - cloud.height * 0.1, cloud.height * 0.6, 0, Math.PI * 2);
        ctx.arc(cloud.x + cloud.width * 0.5, cloud.y, cloud.height * 0.7, 0, Math.PI * 2);
        ctx.arc(cloud.x + cloud.width * 0.75, cloud.y - cloud.height * 0.05, cloud.height * 0.5, 0, Math.PI * 2);
        ctx.arc(cloud.x + cloud.width, cloud.y, cloud.height / 2, 0, Math.PI * 2);
        ctx.fill();
      });
      
      // Draw background layers
      bgLayers.forEach(layer => {
        ctx.fillStyle = layer.color;
        ctx.fillRect(layer.x, canvas.height - 100, layer.width, 100);
        
        // Draw second copy for seamless scrolling
        ctx.fillRect(layer.x + layer.width, canvas.height - 100, layer.width, 100);
      });
    }
    
    // Draw ground
    function drawGround() {
      // Draw ground
      ctx.fillStyle = '#8B7355';
      ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
      
      // Draw ground line
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, canvas.height - 50);
      ctx.lineTo(canvas.width, canvas.height - 50);
      ctx.stroke();
    }
    
    // Draw dino
    function drawDino(x, y, width, height, state) {
      ctx.save();
      
      // Blink animation
      if (frameCount % 200 < 5) {
        dino.blinkAnimation = 1;
      } else {
        dino.blinkAnimation = 0;
      }
      
      // Draw dino body
      ctx.fillStyle = '#4CAF50';
      ctx.fillRect(x, y, width, height);
      
      // Draw dino head
      ctx.fillRect(x + width * 0.7, y - height * 0.3, width * 0.4, height * 0.6);
      
      // Draw dino eye
      ctx.fillStyle = '#FFF';
      ctx.fillRect(x + width * 0.85, y - height * 0.2, width * 0.15, height * 0.15);
      
      // Draw pupil (or closed eye)
      if (dino.blinkAnimation) {
        ctx.fillStyle = '#000';
        ctx.fillRect(x + width * 0.85, y - height * 0.15, width * 0.15, height * 0.05);
      } else {
        ctx.fillStyle = '#000';
        ctx.fillRect(x + width * 0.9, y - height * 0.15, width * 0.05, height * 0.05);
      }
      
      // Draw dino legs based on state
      if (state === 'run') {
        // Animate legs
        dino.legAnimation = (dino.legAnimation + 1) % 20;
        
        // Leg 1
        if (dino.legAnimation < 10) {
          ctx.fillRect(x + width * 0.2, y + height, width * 0.15, height * 0.4);
        } else {
          ctx.fillRect(x + width * 0.2, y + height, width * 0.15, height * 0.2);
          ctx.fillRect(x + width * 0.15, y + height + height * 0.2, width * 0.05, height * 0.2);
        }
        
        // Leg 2
        if (dino.legAnimation >= 10) {
          ctx.fillRect(x + width * 0.6, y + height, width * 0.15, height * 0.4);
        } else {
          ctx.fillRect(x + width * 0.6, y + height, width * 0.15, height * 0.2);
          ctx.fillRect(x + width * 0.65, y + height + height * 0.2, width * 0.05, height * 0.2);
        }
      } else if (state === 'jump') {
        // Legs bent when jumping
        ctx.fillRect(x + width * 0.2, y + height * 0.8, width * 0.15, height * 0.4);
        ctx.fillRect(x + width * 0.6, y + height * 0.8, width * 0.15, height * 0.4);
      } else if (state === 'duck') {
        // Shorter body when ducking
        ctx.fillStyle = '#4CAF50';
        ctx.fillRect(x, y + height * 0.5, width, height * 0.5);
        
        // Legs
        ctx.fillRect(x + width * 0.2, y + height, width * 0.15, height * 0.2);
        ctx.fillRect(x + width * 0.6, y + height, width * 0.15, height * 0.2);
      } else if (state === 'dead') {
        // Legs splayed when dead
        ctx.fillRect(x - width * 0.1, y + height, width * 0.15, height * 0.2);
        ctx.fillRect(x + width * 0.3, y + height, width * 0.15, height * 0.2);
        ctx.fillRect(x + width * 0.6, y + height, width * 0.15, height * 0.2);
        ctx.fillRect(x + width * 0.9, y + height, width * 0.15, height * 0.2);
      } else {
        // Standing still
        ctx.fillRect(x + width * 0.2, y + height, width * 0.15, height * 0.4);
        ctx.fillRect(x + width * 0.6, y + height, width * 0.15, height * 0.4);
      }
      
      ctx.restore();
    }
    
    // Draw obstacles
    function drawObstacles() {
      obstacles.forEach(obstacle => {
        if (obstacle.type === 'cactus') {
          // Draw cactus
          ctx.fillStyle = '#8B4513';
          ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
          
          // Draw cactus arms
          ctx.fillRect(obstacle.x - obstacle.width * 0.3, obstacle.y + obstacle.height * 0.3, obstacle.width * 0.3, obstacle.height * 0.2);
          ctx.fillRect(obstacle.x + obstacle.width, obstacle.y + obstacle.height * 0.5, obstacle.width * 0.3, obstacle.height * 0.2);
        } else if (obstacle.type === 'bird') {
          // Draw bird
          ctx.fillStyle = '#FF5722';
          
          // Body
          ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
          
          // Wings
          const wingFlap = Math.sin(frameCount * 0.2) * 5;
          ctx.fillRect(obstacle.x - obstacle.width * 0.3, obstacle.y + wingFlap, obstacle.width * 0.3, obstacle.height * 0.5);
          ctx.fillRect(obstacle.x + obstacle.width, obstacle.y - wingFlap, obstacle.width * 0.3, obstacle.height * 0.5);
          
          // Beak
          ctx.fillStyle = '#FFC107';
          ctx.beginPath();
          ctx.moveTo(obstacle.x - obstacle.width * 0.2, obstacle.y + obstacle.height * 0.5);
          ctx.lineTo(obstacle.x, obstacle.y + obstacle.height * 0.4);
          ctx.lineTo(obstacle.x, obstacle.y + obstacle.height * 0.6);
          ctx.closePath();
          ctx.fill();
        }
      });
    }
    
    // Draw power-ups
    function drawPowerUps() {
      powerUps.forEach(powerUp => {
        // Draw star
        ctx.fillStyle = '#FFD700';
        ctx.save();
        ctx.translate(powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2);
        ctx.rotate(frameCount * 0.05);
        
        // Draw star shape
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
          const x = Math.cos(angle) * powerUp.width / 2;
          const y = Math.sin(angle) * powerUp.height / 2;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      });
    }
    
    // Draw particles
    function drawParticles() {
      particles.forEach(particle => {
        ctx.fillStyle = particle.color;
        ctx.globalAlpha = particle.alpha;
        ctx.fillRect(particle.x, particle.y, particle.width, particle.height);
        ctx.globalAlpha = 1;
      });
    }
    
    // Draw score
    function drawScore() {
      ctx.fillStyle = '#333';
      ctx.font = '20px "Press Start 2P"';
      ctx.textAlign = 'left';
      ctx.fillText('Score: ' + score, 20, 30);
      
      // Draw distance
      ctx.font = '16px "Press Start 2P"';
      ctx.fillText('Distance: ' + Math.floor(distance / 10) + 'm', 20, 55);
      
      // Draw speed indicator
      ctx.fillText('Speed: ' + Math.floor(gameSpeed), 20, 80);
    }
    
    // Update game
    function update() {
      if (gameState !== 'play') return;
      
      frameCount++;
      distance += gameSpeed;
      
      // Update score
      if (frameCount % 10 === 0) {
        score++;
      }
      
      // Increase difficulty over time
      if (frameCount % 500 === 0 && gameSpeed < 15) {
        gameSpeed += 0.5;
      }
      
      // Update dino
      if (dino.isJumping) {
        dino.y += dino.dy;
        dino.dy += gravity;
        
        if (dino.y >= canvas.height - 150 - dino.height) {
          dino.y = canvas.height - 150 - dino.height;
          dino.dy = 0;
          dino.isJumping = false;
        }
      }
      
      // Update background layers
      bgLayers.forEach(layer => {
        layer.x -= layer.speed * gameSpeed;
        
        // Reset position when out of view
        if (layer.x <= -layer.width) {
          layer.x = 0;
        }
      });
      
      // Update clouds
      clouds.forEach(cloud => {
        cloud.x -= cloud.speed * gameSpeed;
        
        // Reset position when out of view
        if (cloud.x <= -cloud.width * 2) {
          cloud.x = canvas.width + cloud.width;
          cloud.y = Math.random() * (canvas.height / 2);
        }
      });
      
      // Update obstacles
      obstacles.forEach(obstacle => {
        obstacle.x -= gameSpeed;
        
        // Update bird position
        if (obstacle.type === 'bird') {
          obstacle.y = canvas.height - 150 - 100 - Math.sin(frameCount * 0.05) * 30;
        }
      });
      
      // Remove off-screen obstacles
      obstacles = obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);
      
      // Generate new obstacles
      if (frameCount % (100 - Math.floor(gameSpeed * 2)) === 0) {
        const obstacleType = Math.random() > 0.7 ? 'bird' : 'cactus';
        
        if (obstacleType === 'cactus') {
          const cactusHeight = 40 + Math.random() * 40;
          obstacles.push({
            type: 'cactus',
            x: canvas.width,
            y: canvas.height - 150 - cactusHeight,
            width: 20 + Math.random() * 20,
            height: cactusHeight
          });
        } else {
          obstacles.push({
            type: 'bird',
            x: canvas.width,
            y: canvas.height - 150 - 100,
            width: 40,
            height: 30
          });
        }
      }
      
      // Update power-ups
      powerUps.forEach(powerUp => {
        powerUp.x -= gameSpeed;
        powerUp.y += Math.sin(frameCount * 0.1) * 0.5;
      });
      
      // Remove off-screen power-ups
      powerUps = powerUps.filter(powerUp => powerUp.x + powerUp.width > 0);
      
      // Generate new power-ups
      if (frameCount % 500 === 0 && Math.random() > 0.5) {
        powerUps.push({
          x: canvas.width,
          y: canvas.height - 150 - 100 - Math.random() * 100,
          width: 30,
          height: 30
        });
      }
      
      // Update particles
      particles.forEach(particle => {
        particle.x += particle.dx;
        particle.y += particle.dy;
        particle.dy += 0.2;
        particle.alpha -= 0.02;
      });
      
      // Remove faded particles
      particles = particles.filter(particle => particle.alpha > 0);
      
      // Check collisions with obstacles
      obstacles.forEach(obstacle => {
        if (
          dino.x < obstacle.x + obstacle.width &&
          dino.x + dino.width > obstacle.x &&
          dino.y < obstacle.y + obstacle.height &&
          dino.y + dino.height > obstacle.y
        ) {
          // Create explosion particles
          for (let i = 0; i < 20; i++) {
            particles.push({
              x: dino.x + dino.width / 2,
              y: dino.y + dino.height / 2,
              width: 5 + Math.random() * 5,
              height: 5 + Math.random() * 5,
              dx: (Math.random() - 0.5) * 5,
              dy: (Math.random() - 0.5) * 5 - 2,
              color: '#FF5722',
              alpha: 1
            });
          }
          
          // Play game over sound
          if (soundEnabled) {
            // In a real implementation, you would play an actual sound file
            console.log('Game over sound');
          }
          
          gameState = 'gameover';
        }
      });
      
      // Check collisions with power-ups
      powerUps.forEach((powerUp, index) => {
        if (
          dino.x < powerUp.x + powerUp.width &&
          dino.x + dino.width > powerUp.x &&
          dino.y < powerUp.y + powerUp.height &&
          dino.y + dino.height > powerUp.y
        ) {
          // Remove the power-up
          powerUps.splice(index, 1);
          
          // Add bonus score
          score += 50;
          
          // Create star particles
          for (let i = 0; i < 10; i++) {
            particles.push({
              x: powerUp.x + powerUp.width / 2,
              y: powerUp.y + powerUp.height / 2,
              width: 3 + Math.random() * 3,
              height: 3 + Math.random() * 3,
              dx: (Math.random() - 0.5) * 3,
              dy: (Math.random() - 0.5) * 3 - 1,
              color: '#FFD700',
              alpha: 1
            });
          }
          
          // Play power-up sound
          if (soundEnabled) {
            // In a real implementation, you would play an actual sound file
            console.log('Power-up sound');
          }
        }
      });
    }
    
    // Draw game
    function draw() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      if (gameState === 'menu') {
        drawMenu();
      } else if (gameState === 'play') {
        drawBackground();
        drawGround();
        drawPowerUps();
        drawObstacles();
        drawParticles();
        
        // Draw dino with appropriate state
        let dinoState = 'run';
        if (dino.isJumping) {
          dinoState = 'jump';
        } else if (dino.isDucking) {
          dinoState = 'duck';
        }
        
        drawDino(dino.x, dino.y, dino.width, dino.height, dinoState);
        drawScore();
      } else if (gameState === 'paused') {
        drawBackground();
        drawGround();
        drawPowerUps();
        drawObstacles();
        drawDino(dino.x, dino.y, dino.width, dino.height, 'stand');
        drawScore();
        drawPauseScreen();
      } else if (gameState === 'gameover') {
        drawGameOver();
      }
    }
    
    // Game loop
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }
    
    // Event listeners
    document.addEventListener('keydown', function(e) {
      if (gameState === 'menu' && e.code === 'Enter') {
        resetGame();
        gameState = 'play';
      } else if (gameState === 'gameover' && e.code === 'Enter') {
        resetGame();
        gameState = 'play';
      } else if (gameState === 'play') {
        if ((e.code === 'Space' || e.code === 'ArrowUp') && !dino.isJumping) {
          dino.dy = dino.jumpPower;
          dino.isJumping = true;
          dino.isDucking = false;
          
          // Play jump sound
          if (soundEnabled) {
            // In a real implementation, you would play an actual sound file
            console.log('Jump sound');
          }
          
          // Create dust particles
          for (let i = 0; i < 5; i++) {
            particles.push({
              x: dino.x + dino.width / 2,
              y: dino.y + dino.height,
              width: 3 + Math.random() * 3,
              height: 3 + Math.random() * 3,
              dx: (Math.random() - 0.5) * 2,
              dy: Math.random() * -1,
              color: '#8B7355',
              alpha: 0.7
            });
          }
        } else if (e.code === 'ArrowDown' && !dino.isJumping) {
          dino.isDucking = true;
          dino.height = 30;
        }
      } else if (gameState === 'play' && e.code === 'KeyP') {
        gameState = 'paused';
      } else if (gameState === 'paused' && e.code === 'KeyP') {
        gameState = 'play';
      }
    });
    
    document.addEventListener('keyup', function(e) {
      if (gameState === 'play' && e.code === 'ArrowDown') {
        dino.isDucking = false;
        dino.height = 60;
      }
    });
    
    // Touch controls for mobile
    document.addEventListener('touchstart', function(e) {
      e.preventDefault();
      
      if (gameState === 'menu') {
        resetGame();
        gameState = 'play';
      } else if (gameState === 'gameover') {
        resetGame();
        gameState = 'play';
      } else if (gameState === 'play') {
        if (!dino.isJumping) {
          dino.dy = dino.jumpPower;
          dino.isJumping = true;
          dino.isDucking = false;
          
          // Play jump sound
          if (soundEnabled) {
            // In a real implementation, you would play an actual sound file
            console.log('Jump sound');
          }
          
          // Create dust particles
          for (let i = 0; i < 5; i++) {
            particles.push({
              x: dino.x + dino.width / 2,
              y: dino.y + dino.height,
              width: 3 + Math.random() * 3,
              height: 3 + Math.random() * 3,
              dx: (Math.random() - 0.5) * 2,
              dy: Math.random() * -1,
              color: '#8B7355',
              alpha: 0.7
            });
          }
        }
      } else if (gameState === 'paused') {
        gameState = 'play';
      }
    });
    
    // Mobile control buttons
    jumpBtn.addEventListener('touchstart', function(e) {
      e.preventDefault();
      
      if (gameState === 'play' && !dino.isJumping) {
        dino.dy = dino.jumpPower;
        dino.isJumping = true;
        dino.isDucking = false;
        
        // Play jump sound
        if (soundEnabled) {
          // In a real implementation, you would play an actual sound file
          console.log('Jump sound');
        }
        
        // Create dust particles
        for (let i = 0; i < 5; i++) {
          particles.push({
            x: dino.x + dino.width / 2,
            y: dino.y + dino.height,
            width: 3 + Math.random() * 3,
            height: 3 + Math.random() * 3,
            dx: (Math.random() - 0.5) * 2,
            dy: Math.random() * -1,
            color: '#8B7355',
            alpha: 0.7
          });
        }
      }
    });
    
    duckBtn.addEventListener('touchstart', function(e) {
      e.preventDefault();
      
      if (gameState === 'play' && !dino.isJumping) {
        dino.isDucking = true;
        dino.height = 30;
      }
    });
    
    duckBtn.addEventListener('touchend', function(e) {
      e.preventDefault();
      
      if (gameState === 'play') {
        dino.isDucking = false;
        dino.height = 60;
      }
    });
    
    // Pause button
    pauseBtn.addEventListener('click', function() {
      if (gameState === 'play') {
        gameState = 'paused';
      } else if (gameState === 'paused') {
        gameState = 'play';
      }
    });
    
    // Sound button
    soundBtn.addEventListener('click', function() {
      soundEnabled = !soundEnabled;
      soundBtn.textContent = soundEnabled ? 'üîä' : 'üîá';
    });
    
    // Initialize game
    init();
  </script>
</body>
</html>
